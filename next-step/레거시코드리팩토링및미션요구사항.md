##
현장에 있는 레거시 코드들을 안정적으로 리팩토링하기 위함이다.
결과물이 어떤 모습이여야 하고, 어떤 모습인지 보는 눈이 있어야지 리팩토링 할수 있다.
DB와 UI결합이 되면 클린코드 객체지향 설계가 어렵다.
그래서 콘솔기반의 TDD를 연습시키는 것이다.
객체지향 설계 코드는 어떻고 클린코드는 어떻고 TDD는 어떤지 인지한 상태에서
미션을 진행하다보면 코드를 보는 눈이 생긴다.

눈높이를 높게 만드는것이 중요하다.
현장에 있는 레거시 코드들을 리팩토링 하는걸 목표로 한다.
미션들을 백날해도 레거시 코드들을 리팩토링 하지 않으면 의미없다.

모든 과정을 설계하기에는 어렵기 때문에, 웹 어플리케이션을 통해서 클린코드를 해보자
사다리 타기를 끝내도 볼링점수판의 1단계는 무조건 해라
그래야 의미가 있다. 그래야 현장의 레거시코드를 리팩토링 하는 감을 익힐수 있다.

- TO-BE- 한단계 더나아가기
    - ATDD(Acceptance Test Driven Development)기반으로 응용 애플리케이션 개발하기   
    - 레거시 애플리케이션에 테스트 코드를 추가해 리팩토링 하기
        - 이걸잘하면 현장에서 인정받는다.
        - 여러분들은 그 역량을 쌓기 위해서 거치는것이다.

- 다음과 같은 layered architecture 기반 하에 핵심 비지니스 로직은 어디에 구현하는것이 맞을까?

- 현장의 비즈니스 로직은 어디에 구현하는게 맞을까요?
    - 대부분 회사는 서비스 레이어에 구현이 되어있다.
    - 서비스 레이어에서 비즈니스 로직을 구성하는게 맞다고 생각한다 대부분은
    - 이러면 TDD로 구현하는게 어렵다.
    - 유지보수 하기가 어려워진다.
- 현장의 레거시코드들을 리팩토링 하려면 상태를 가지는 도메인으로 리팩토링하는게 좋다.

- 우리나라는 차세대 코드를 하면서 고도화 한다고 하면서 새로 짜긴하는데
- 서비스 레이어에 비즈니스 로직을 만들고 또 쌓이고 고도화.. 무한반복
- 개발자들에게 리팩토링이 중요한 이유이다.
- 단기적으로는 손해인것 같지만 장기적으로는 좋다.


- 응용 애플리케이션(웹, 모바일 애플리케이션)을 개발할 때 이 과정에서 배운 TDD OOP를 적용하려하면
핵심 비즈니스 로직을 도메인 객체가 담당하도록 구현하는 것이다.
- 즉 테스트하기 쉬운 부분과 테스트하기 어려운 부분을 분리해 테스트 하기 쉬운 부분에 대한 단위테스트를 구현하고,
지속적인 리팩토링을 한다.
- 테스트하기 쉬운부분과 테스트하기 어려운부분을 분리하고 spring과 같은 interface기반으로 묶으면 클린해진다.
- Service -> Domain으로 로직을 이동하는게 좋다.

- 레거시 코드 리팩토링의 1단계는
    - Service Layer에 단위 테스트를 추가한 후 비지니스 로직을 도메인 객체로 이동하는 리팩토링
    - Acceptance Test를 추가한후 리팩토링


- 질문 삭제하기 요구사항
    - 질문 데이터를 완전히 삭제하는것이 아니라 데이터의 상태를 삭제상태(deleted - boolean type)으로 변경한다.
    - 로그인 사용자와 질문한 사람이 같은 경우 삭제 가능하다.
    - 답변이 없는 경우 삭제가 가능하다.
    - 질문자와 답변글의 모든 답변자가 같은 경우 삭제가 가능하다.
    - 질문을 삭제할 때 답변 또한 삭제해야 하며, 답변의 삭제 또한 삭제상태(deleted)를 변경한다.
    - 질문자와 답변자가 다른 경우 답변을 삭제할 수 없다.
    - 질문과 답변 삭제 이력에 대한 정보를 DeleteHistory를 활용해 남긴다.

- 프로그래밍 요구사항
    - qna.service.QnaService의 deleteQuestion()는 앞의 질문 삭제 기능을 구현한 코드이다.
    이 메소드는 단위 테스트 하기 어려운 코드와 단위 테스트 가능한 코드가 섞여있다.
    - 단위 테스트 하기 어려운 코드와 단위 테스트 가능한 코드를 분리해 단위 테스트 가능한 코드에 대해 단위
    테스트를 구현한다.
    
- 힌트 : 
