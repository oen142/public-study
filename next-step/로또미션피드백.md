#### 도입
- 로또 미션이 레이싱게임보다 어렵다.
- 조금더 설계가 어려워져야 한다.
- 어떤 친구들은 사다리 타기가 난이도가 제일 높다하고
- 어떤 친구들은 볼링게임이 어렵다고 한다.

- 어떤순간에 프로덕션 코드를 짜고있는 나를 볼수 있다.
- 테스트 케이스를 만드는 순

이런 작은 애플리케이션을 만드는게 목표가 아니라 우리가 맞고있는
레거시 코드들을 문제가 없게 리팩토링 할것인가가 중요하다.
그렇다면 TDD사이클로 만드는게 중요하다.


#### AS-IS
- 학습테스트 - JUni 사용법 및 단위 테스트 연습
- 단위 테스트 - 내가 구현한 코드에 대한 단위 테스트
- TDD - TDD 사이클을 맛보기 단계

#### TO-BE
- TDD -TDD사이클이 익숙해질 때 까지 같은 미션으로 반복 연습

같은 미션을 반복하는게 좋다.
다른 미션으로 하고 싶긴 한데, 같은 미션을 반복연습하는데 좋다.
로또 미션을 구현했다. 사다리 미션을 가면 처음부터 새로해야하기 때문에
TDD가 익숙해지지 않은 상태에서 새로운 미션으로 가게 되면 사이클이 깨진다.

하다가 재미 없으면 사다리타기로 넘어갔다가 다시 자존감이 떨어져, 그러면 자동차 경주게임에서
역행하는것이 좋다.
알고있는걸 연습할때 제일 재밌다.

#### Lotto피드백
- 기능 요구사항
    - 로또 구입금액을 입력하면 구입금액에 해당하는 로또를 발급해야한다.
    - 로또1장의 가격은 1000원이다.

- 시작하기
    - 요구사항 분석을 통한 기능 목록 작성
    - 객체설계를 통해 어느 부분부터 구현을 시작할 것인지 결정

- 기능목록
    - 구매할 Lotto의 매수 구하기
        - 1000 -> 1
        - 1500 -> 1
        - 500 -> error
    - 한장의 Lotto생성
    - 당첨 번호 생성
        - 정상적인 당첨번호 입력
        - 유효하지 않은 당첨번호
    - 한장의 Lotto에 대한 당첨결과 구하기
    - n장의 Lotto에 대한 당첨결과 구하기
    - Lotto결과에 따른 수익률 구하기
    - ...
딱 보면 뭔지 알수 있어야 한다.
TODO리스트라는게 내가 알면 된다.
이런거를 테스트케이스의 하나의 단위라고 생각하면 된다.

현실에서는 로또는 한사람이 10만원이상 구매할수 없다.
그런 부분에 대한 예외처리도 들어가면 좋다.

TDD를 하겠다는건 작은단위로 분리해서 단위별로 구현해서
묶어서 조립해서 완성하겠다는 소리이다.

단위 단위로 기능 분리를 했었다.

#### TDD로 구현할 기능 찾기
- 구현 중간 부분을 자르는 연습을 해야한다.
    - 로또 구매금액을 전달하면 구매할 수 있는 로또의 장수를 반환한다.
    - 구매한 로또와 당첨번호를 넣으면 당첨 결과를 반환한다.
    - 당첨결과를 입력하면 당첨금 총액을 반환한다.
    - 당첨 금액과 구매 금액을 넣으면 수익률을 반환한다.
- 구현 중간부분을 자른다는것은 로또 구현에 필요한 메소드를 찾는 과정이다.

단위를 어떻게 짜르는건 역량에 따라 달라질수도 있다.
무조건 작은단위 or 중간단위에서 작은단위로

TDD를 잘하려면 큰 도메인 객체와 작은 도메인 객체 TDD를 수월하게 하려면
가장 안쪽에 있는 객체를 빨리 도출하면 TDD로 구현하기가 쉬워진다.
가장 안쪽에 있는 단위의 객체를 찾는게 어렵다.
어려우면 가능한 단위의 큰 객체만 만들어서 리팩토링해나가면 좋다.

#### 한장의 Lotto에 대한 당첨 결과 구하기
- 오늘 강의는 객체 설계 경험이 부족한 주니어 개발자이거나,
객체 설계가 부족한 레거시 코드가 존재하는 상황을 가정한 내용이다.

- 시작하기
    - 객체설계를 어떻게 해야할지 모르겠다면 시작은 클래스 메소드 구현으로 시작한 후 지속적인 리팩토링
    - 리팩토링할때는 객체지향 생활체조 원칙, 클린코드 원칙을 참고해 리팩토링
    
- 리팩토링 어디서 시작하면 좋을까?
    - 메서드 분리부터 시작한다.
    - 인덴트를 줄일수 있는 부분을 줄인다.
    - 메서드들이 쪼개지는데, 나중에 메서드 들이 도출하는 클래스로 이동하게 되어있다.
    - 이름이 엉망이면 이름을 리네임하는 리팩토링을 해라
    
- 메소드 분리
    - 규칙 1 한 메서드에 오직 한단계의 들여쓰기만 한다.
    - 들여쓰기를 줄이는 방법
    - 함수가 한가지 일만 잘하도록 구현한다.
        - 정량적인 기준을 만들어 연습한다.
        - 함수의 길이가 15라인을 넘어가지 않도록 구현한다.
- 극단적인 줄임을 하게되면 인사이트를 얻게 된다.
- 기존에 하던 방식으로 하면 안된다. 다르게 방법으로 접근해야한다.

- 클래스 분리
    - 규칙 3: 모든 원시값과 문자열을 포장한다.
    - 규칙 7 : 3개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.
    - 규칙 8 : 일급 콜렉션을 쓴다.
    - 메소드에 인자수를 최소화 한다
        - 메소드에서 이상적인 인자 개수는 0개 1개 2개
        - 3개는 피하면 된다 4개는 없다.
    - private method를 분리해서 단위테스트해야하는것인 아닌가?

#### 클래스간의 의존관계 연결
- 클래스를 분리할때 또는 클래스를 분리한후
- 고민해야할 부분은 클래스간의 의존관계를 어떻게 연결할것인가? 이다.

- 상속(is-a 관계)과 조합(has-a관계)
    - 일급 collection을 구현할때 접근방법으로 상속과 조합방법으로 구현할수있다.
    - 객체의 중복(Lotto와 WinningLotto)을 제거할때 상속과 조합 방법으로 구현할 수 있다.

- 조합을 쓰면 필요한 API만 노출을 시킬수 있다.
    - 코딩량은 늘어날 수 있지만,
- 상속을 쓰면 모든 API들을 노출해야한다.
    - 순환참조가 발생할수는 있지만 분리할수 있다.
    
- 상속과 조합중에서 뭐를 구현하는게 좋을까?
    - 인터페이스 상속은 추천한다.
- 객체간에 조합을 선호한다.

코드의 재사용성 측면에서는 상속이 유리하지만 유연성 측면에서는 조합이더 유리하다.
변화에 빠르게 대응하는것이 점점더 중요해지고 있는 현재는 재사용성보다 유연성이 훨씬 더 중요하다.
상속은 부모가 바뀌면 자식도 다 변경에 대응해야한다.
의존관계를 맺을때는 상속보단 조합이 유연성이 더 높아진다.
최근에 우리가 서비스가 발전하는것을 보니까 변화되는 속도가 빠르게 바뀐다.
우리가 처음에 맞다고 생각했던걸 짰는데 나중에는 바뀔수 있다.

조합으로 관계를 맺어가다가 상속이 맞으면 상속으로 변화하는것도 좋은 방법이다.
상속이 너무 좋다고 해서 상속만 사용해서 하면 변화하기가 힘들다.

스프링 jdbc가 데이터베이스에대한 접근을 쉽게해주는 라이브러리인데,
jdbc template이 있는데, jdbc template를 이용해서 만드는데
dao를 만들어서 만드는데, jdbc 템플릿을 하는데, jdbc. 하는게 싫었다.
나중에 상속하면서 썼는데, jdbc들이 변경되었을때 밑에 바뀌는게 너무 많았다.

#### 추가 리팩토링
- 생성자 대신 정적 팩토리 메서드를 사용하라
- 가변객체보다 불변객체 기반으로 구현하라.
    - 버그발생 가능성이 줄어든다.

- 생성자 대신 정적 팩토리 메서드를 사용하라
    - 이름을 가짐으로써 객체 생성의 의도를 드러낼수 있다.
    - 호출될때 마다 인스턴스를 새로 생성하지 않아도 된다. - singleton 패턴을 적용할 경우
    - 반환 타입의 하위 타입 객체를 반환할 수 있다.
    - 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
- 명명규칙
    - valueOf() , of() : 인자로 전달되는 값에 해당하는 인스턴스를 반환 type-conversion method
    - getInstance(), newInstance(): 보통 자신과 같은 Type의 인스턴스를 반환, singleton 패턴에서 사용
    - getType() , newType() : 자신과 다른 Type의 인스턴스를 반환

- 가변객체vs불변객체
    - 불변객체 만들기
        - 객체 상태를 변경하는 메소드를 제공하지 않는다.
        - 클래스를 확장할 수 없도록 한다.
        - 모든 필드를 final로 선언한다.
            - 리스트는 불가능할수도 있음
        - 모든 필드를 private로 선언한다.
- 불변객체적용과 관련해 종종듣는질문
    - 불변객체가 좋은것은 알겠는데, 인스턴스가 너무 많이 생성되어 성능이 떨어지는것은 아닌가?
    - (예) Lotto생성하면 LottoNum이 계속 생성됨
    - 10000명이 쓴다고 하면 엄청 많이 생성된다.
    - 더 해결방법이 없는지 고민을 한다.
    - 캐싱을 적용해 인스턴스 생성을 최소화할수 있는 방법이 있는지 검토한다.
    - 캐싱을 쓸때 많이 쓰는 자료구조는 Map이다 어디든 key , value값을 많이 쓴다.
    - 프로그래밍 상의 캐시를 위해서 API를 제공한다. MAP으로
    - Integer는 개인적으로 캐싱전략을 쓰고 있다.
    
- 성능을 고려하면서 구현하는 습관은 좋은 습관이다.
하지만 성능만 고려하는 것은 아닌지 한번쯤 의구심을 가져봐야한다.
성능 외에도 유지보수하기 좋은 코드, 읽기 좋은 코드, 유연한 코드, 버그 발생 가능성이 낮은 코드
와 같이 다양한 측면을 고려하면서 프로그래밍하는 습관을 가지는 것이 더 중요하다.

클린코드만 지향한다는 잘못된거다. 뭔가를 할때 한가지만 하기보다는 다양한 관점으로 봐야한다.
뭐든지 정답이 없다. 틀을 깨야한다. 정답을 찾으려는 습관이 들었는데, 프로그래밍에 정답은 없다.
이것을 깨달았을때 엄청 많이 성장한다.
성능만 추구하는건 좋은 프로그래밍 방식이 아니다.
