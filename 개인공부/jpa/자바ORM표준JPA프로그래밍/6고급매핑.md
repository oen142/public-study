## 상속관계 매핑

- 관계형 데이터베이스는 상속관계가 없다.
- 슈퍼타입 서브타입 관계라는 모델링 기법이 객체 상속과 상당히 유사하다.
- 상속관계 매핑을 통해서 객체의 상속 구조와 DB의 슈퍼타입 또는 서브타입의 관계를 매핑한다.

- 슈퍼타입 서브타입 논리 모델을 실제 물리 모델로 구현하는 방법
    - 각각 테이블로 전환한다. -> 조인 전략
    - 통합 테이블로 변환한다. -> 단일 테이블 전략
    - 서브타입 테이블로 변환한다. -> 구현 클래스 마다 테이블 전략

- 주요 어노테이션
    - @Inheritance(strategy=InheritanceType.xxx)
        - JOINED : 조인 전략
        - SINGLE_TABLE : 단일 테이블 전략
        - TABLE_PER_CLASS : 구현 클래스 마다 테이블 전략
    - @DiscriminatorColumn(name="DTYPE")
    - @DiscriminatorValue("XXX")
    
- 조인 전략
    - 장점
        - 테이블 정규화
        - 외래 키 참조 무결성 제약 조건 활용 가능
        - 저장 공간 효율화
    - 단점
        - 조회시 조인을 많이 사용, 성능 저하
        - 조회 쿼리가 복잡 하다.
        - 데이터 저장시 INSERT SQL 2번 호출

- 단일 테이블 전략
    - 장점
        - 조인이 필요 없으므로 일반적으로 조회 성능이 빠르다.
        - 조회 쿼리가 단순하다.
    - 단점
        - 자식 엔티티가 매핑한 컬럼은 모두 null 허용을 한다.
        - 단일 테이블에 모든 것을 저장하므로 테이블이 커질수 있다. 상황에 따라 조회 성능이 오히려 느려질수 있다.
        
- 구현 클래스마다 테이블 전략   
    - 이 전략은 데이터베이스 설계자와 ORM 전문가 둘다 추천하지 않는다.
    - 장점
        - 서브 타입을 명확하게 구분해서 처리할 때 효과적이다.
        - not null 제약 조건 사용 가능하다.
    - 단점
        - 여러 자식 테이블을 함께 조회할 때 성능이 느리다(UNION SQL 필요하다.)
        - 자식 테이블을 통합해서 쿼리하기가 어렵다.
        

## Mapped Superclass - 매핑 정보 상속

- 공통 매핑 정보가 필요할 때 사용한다.(id , name)

- 상속관계 매핑을 하지 않는다.
- 엔티티 하지 않고, 테이블과 매핑 하지 않는다.
- 부모 클래스를 상속 받는 자식 클래스에 매핑 정보만 제공한다.
- 조회, 검색 불가(em.find(BaseEntity) 불가능하다.)
- 직접 생성해서 사용할 일이 없으므로 추상 클래스를 권장한다.


- 테이블과 관계 없고, 단순히 엔티티가 공통으로 사용하는 매핑 정보를 모으는 역할을 한다.
- 주로 등록일, 수정일, 등록자, 수정자 같은 전체 엔티티에서 공통으로 적용하는 정보를 모을 때 사용
- 참고 : @Entity 클래스는 엔티티나 @MappedSuperclass로 지정한 클래스만 상속 가능
