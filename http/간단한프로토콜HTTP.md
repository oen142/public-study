# 간단한 프로토콜 HTTP

- HTTP는 클라이언트와 서버간에 통신을 한다.
- 리퀘스트와 리스폰스를 교환하여 성립
- HTTP는 상태를 유지하지 않는 프로토콜
- 리퀘스트 URI로 리소스를 식별
- 서버에 임무를 부여하는 HTTP메소드
- 메소드를 사용해서 지시를 내리다.
- 지속 연결로 접속량을 절약
    - 지속 연결
    - 파이프라인화
- 쿠키를 사용한 상태관리

## HTTP는 클라이언트와 서버간에 통신을 한다.

- 클라이언트 : 텍스트 이미지등과 같은 리소스를 필요하다고 요구하는 쪽
- 서버 : 리소스를 제공하는 쪽

- HTTP를 사용시 2대의 컴퓨터 간에 통신할 셩우 한번 통신을 할때마다 반드시 어느한쪽은 클라이언트 다른 한쪽은 서버가 된다.
- HTTP는 클라이언트와 서버의 역할을 명확하게 구별하고 있다.

## 리퀘스트와 리스폰스를 교환하여 성립

- HTTP는 클라이언트로부터 리퀘스트가 송신되며, 그결과가 서버로부터 리스폰스로 되돌아 온다.
- 반드시 클라이언트측으로 부터 통신이 시작된다.
- 서버 측은 리퀘스트를 받지않고서는 리스폰스를 송신하는 일은 없다.

- 리퀘스트의 메시지는 메소드, URI, 프로토콜 버전, 옵션리퀘스트 헤더 필드와 엔티티로 구성되어 있다.

- 리스폰스의 메시지는 프로토콜 버전, 상태코드, 상태코드를 설명한 프레이즈 , 옵션의 리스폰스 헤더 필드와 바디로 구성되어있다.

## HTTP는 상태를 유지하지 않는 프로토콜
- HTTP는 상태를 계속 유지하지 않는 stateless 프로토콜이다.
- HTTP는 독자적으로 리퀘스트와 리스폰스를 교환하는 동안에 status를 관리하지 않는다.
- HTTP에서는 새로운 리퀘스트가 보내질 때마다 새로운 리스폰스가 생성된다.
- 하지만 상태를 유지해야하는 경우가 있다. 그래서 나온게 쿠키라는 기술이다.
- 쿠키로 인해 HTTP를 이용한 통신에서도 상태를 계속 관리할수 있게 되었다.

## 리퀘스트 URI로 리소스를 식별

- HTTP는 URI를 사용하여 인터넷 상의 리소스를 지정한다.
- 클라이언트는 리소스를 호출할 때 마다 리퀘스트를 송신할 때에 리퀘스트안에 URI를 리퀘스트 URI라고 불리는 형식으로 포함해야 할 필요가 있다.

> http://test.com/index.html 을 리퀘스트 하는 경우
- 모든 URI를 리퀘스트 URI에 포함한다.
    - `GET http://test.com/index.html HTTP/1.1`
- HOST 헤더 필드에 네트워크 로케이션을 포함한다.
    - `GET /index.html HTTP/1.1 \n HOST: test.com`
    
## 서버에 임무를 부여하는 HTTP 메소드

- GET : 리소스 획득
    - GET 메소드는 리퀘스트 URI로 식별된 리소스를 가져올 수 있도록 요구 한다.
    - 가져올 리소스 내용은 지정된 리소스를 서버가 해석한 결과이다.
    - 리소스가 텍스트면 그대로 반환하고 CGI와 같은 프로그램이면 실행해서 출력된 결과를 반환단다.

- POST : 엔티티 전송
    - GET으로도 엔티티를 전송가능하지만, 일반적으로 POST를 사용한다.
    - POST는 GET과 기능이 비슷하지만, 리스폰스에 의한 엔티티를 획득하는것만이 목적은 아니다.
- PUT : 파일 전송
    - PUT 메소드는 파일 전송하기 위해서 사용됩니다. FTP에 의한 파일 업로드와 같이, 리퀘스트 중에 포함된 엔티티를 리퀘스트 URI
    로 지정한 곳에 보존하도록 요구한다.
    - HTTP/1.1 PUT 자체에는 인증기능이 없기에 보안상의 문제가 있어서 일반적인 웹 사이트에서는 사용하지 않는다.
    - 웹 어플리케이션 등에 의한 인증 기능과 짝을 이루는 경우나 REST와 같이 웹끼리 연계하는 설계양식을 사용할때
    이용하는 경우가 많다.
- HEAD : 메시지 헤더 취득
    - HEAD 메소드는 GET과 같은 기능이지만 메시지 바디는 돌려주지 안흔다.
    - URI 유효성과 리소스 갱신 시간 확인 목적으로 사용된다.
- DELETE : 파일 삭제
    - DELETE는 파일을 삭제하기 위해 사용된다.
    - PUT과는 반대로 동작한다.
    - 리퀘스트 URI로 지정된 리소스의 삭제를 요구한다.
    - HTTP/1.1 PUT 자체에는 인증기능이 없기에 보안상의 문제가 있어서 일반적인 웹 사이트에서는 사용하지 않는다.
    - 웹 어플리케이션 등에 의한 인증 기능과 짝을 이루는 경우나 REST와 같이 웹끼리 연계하는 설계양식을 사용할때
    이용하는 경우가 많다.
- OPTION : 제공하고 있는 메소드의 문의   
    - OPTIONS메소드는 리퀘스트 URI로 지정한 리소스가 제공하고 있는 메소드를 조사하기 위해 사용한다.
- TRACE : 경로 조사
    - TRACE 메소드는 Web 서버에 접속해서 자신에게 통신을 되돌려 받는 루프백을 발생시킨다.
    - 리퀘스트를 보낼때 `Max-Forwards`라는 헤더 필드에 수치를 포함시켜서 서버를 통과할 때 마다 그 수치를 줄여간다.
    - 수치가 0이된 곳을 끝으로, 리퀘스트를 마지막으로 수신한 곳에서 상태코드 200OK리스폰스를 되돌려 준다.
    - 클라이언트틑 TRACE 메소드를 사용함으로써, 리퀘스트를 보낸 곳에 어떤 리퀘스트가 가공되어 있는지 등을 조사할 수 있다.
    - 프록시 등을 중계하여 오리진 서버에 접속할때 그 동작을 확인하기 위해서 사용된다.
    - 다만, TRACE 메소드는 거의 사용되지 않는데다가 크로스사이트트레이싱과 같은 공격을 일으키는 보안상의 문제도 있기 때문에
    보통은 사용되지 않는다.
- CONNECT : 프록시에 터널링 요구
    - CONNECT 메소드는 프록시에 터널 접속 확립을 요함으로써 TCP 통신을 터널링 시키기 위해서 사용된다.
    - 주로 SSL이랑 TSL 등의 프로토콜로 암호화 된 것을 터널링 시키기 위해서 사용된다.
    - CONNECT 프록시서버 : 포트 HTTP 버전

## 메소드를 사용해서 지시를 내리다
- 리퀘스트 URI로 지정한 리소스에 리퀘스트를 보내는 경우에 메소드라고 불리는 명령이 있다.
- 메소드는 리소스에 어떤 행동을 하기 원하는지를 지시하기 위해 존재한다.
- 메소드는 대문자와 소문자를 구별하기 때문에 대문자로 기재해야한다.    
    - GET : 리소스 취득 / 1.0 1.1
    - POST : 엔티티 바디 전송 / 1.0 1.1
    - PUT : 파일 전송 1.0 1.1
    - HEAD
    - DELETE
    - OPTIONS
    - TRACE
    - CONNECT
    - LINK
    - UNLINK 
    
|메소드|설명|제공되는 HTTP 버전|
|---|--------------|-----|
|GET|리소스 취득|1.0 ,1.1|
|POST|엔티티 바디 전송|1.0 , 1.1|
|PUT|파일 전송|1.0 , 1.1|
|HEAD|메시지 헤더 취득|1.0 ,1.1|
|DELETE|파일 삭제|1.0 , 1.1|
|OPTIONS|서포트 하고 있는 메소드 문의|1.1|
|TRACE|경로 조사|1.1|
|CONNECT|프록시에 터널링 요구|1.1|
|LINK|리소스 간에 링크 관계를 확립|1.0|
|UNLINK|링크 관계 삭제|1.0|


## 지속 연결로 접속량을 절역

- HTTP 초기 버전에서는 HTTP 통신을 한번 할 때마다 TCP에 의해 연결과 종료를 할 필요가 있었다.
- 초기 당시의 통신에서는 작은 사이즈의 텍스트를 보내는 정도 였기 때문에 문제가 없었다.
- 하지만 HTTP가 널리 보급되면서 다량의 이미지를 포함한 문서가 늘어났다.
- 그렇기 때문에 리퀘스트를 보낼때 마다 매번 TCP연결과 종료를 하게 되는 쓸모없는 일이 발생되어 통신량이 늘어나게 된다.

## 지속 연결

- HTTP/1.1과 일부 HTTP/1.0 에서는 TCP 연결 문제를 해결하기 위해 지속연결이라는 방법을 고안하였다.
- 지속 연결의 특징은 어느 한 쪽이 명시적으로 연결을 종료하지 않는 이상 TCP연결을 유지한다.
- 지속연결을 하는 이점은 TCP 커넥션의 연결과 종료를 반복되는 오버헤드를 줄여주기 때문에 서버에 대한 부하가 경감된다.
- 오버헤드를 줄인 HTTP리퀘스트와 리스폰스가 빠르게 완료되기 때문에 웹페이지를 빨리 표시할 수 있다.
- HTTP/1.1에서는 표준 동작이지만 , HTTP/1.0에서는 정식 사양이 아니였다.
- 일부 서버에서는 사양에 없는 기능을 구현해서 지속 연결을 가능하게 한 것도 있지만, 반드시 지속 연결이 지원되고 있다고는 할수가없다.

## 파이프라인화
- 지속 연결은 여러 리퀘스트를 보낼 수 있도록 파이프라인화를 가능하게 한다.
- 파이프라인화에 의해서, 이전에는 리퀘스트 송신 후에 리스폰스를 수신할 때 까지 기다린 뒤에 리퀘스트를 발행하던 것을
피스폰스를 기다리지 않고 다음 리퀘스트를 보낼수가 있다.
- 리퀘스트가 늘어날 수록 개별 연결보다 지속연결이 리퀘스트가 빠로그 지속연결보다 파이프라인화 쪽이 빠르다.

## 쿠키를 사용한 상태관리
- HTTP는 stateless 프로토콜 이기 때문에 과거에 교환했었던 리퀘스트와 리스폰스의 상태를 관리하지 않는다.
- 과거 상태를 근거로 해서 현재 리퀘스트를 처리 한다는것은 불가능 하다.
- 예를들면 다른 웹페이지로 이동할때 재차 로그인 정보를 보내든지 리퀘스트 매개변수나 추가정보를 붙여서 로그인 상태를 관리해야한다.
- stateless의 이점은 상태를 유지 하지 않기 때문에 서버의 CPU나 메모리 같은 리소스의 소비를 억제가 가능하다.
- 이 문제를 해결하기 위해 쿠키라는 시스템이 생겼다.
- 쿠키는 리퀘스트와 리스폰스에 쿠키 정보를 추가해서 클라이언트의 상태를 파악하기 위한 시스템이다.
- 쿠키는 서버에서 리스폰스로 보내진 Set-Cookie라는 헤더 필드에 의해 쿠키를 클라이언트에 보존하게 된다.
- 다음번에 클라이언트가 같은 서버로 리퀘스트를 보낼때 자동으로 쿠키값을 넣어서 송신한다.
- 서버는 클라이언트가 보내온 쿠키를 확인해서 어느 클라이언트가 접속했는지 체크하고 서버상의 기록을 확인해서 이전상태를 알수가 있다.
 
