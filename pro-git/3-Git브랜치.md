## 브랜치란 무엇인가

Git이 브랜치를 다루는 과정을 이해하려면 우성 Git이 데이터를 어떻게 저장하는지 알아야한다.
Git은 데이터를 Change Set이나 변경사항으로 기록하지 않고 일련의 스냅샷으로 기록한다.

커밋하면 Git은 현 Staging Area에 있는 데이터의 스냅샷에대한 포인터, 저자나 커밋 메시지같은 메타데이터, 이전 커밋에 대한 포인터등을 포함하는
커밋 개체(Commit Object)를 저장한다. 이전 커밋 포인터가 있어서 현재 커밋이 무엇을 기준으로 바뀌엇는지를 알 수 있다.
최초 커밋을 제외한 나머지 커밋은 이전 커밋 포인터가 적어도 하나씩있고 브랜치를 합친 Merge 커밋 같은 경우 이전 커밋 포인터가 여러개 있다.

파일이 3개 있는 디렉 토리가 하나있고 이 파일을 Staging Area에 저장하고 커밋하는 예제를 살펴보자. 파일을 Stage하면
Git 저장소에 파일을 저장하고 (Git은 이것을 Blob라고 부른다) Staging Area에 해당 파일의 체크섬을 저장한다.

`$ git add README test.rb LICENSE`

`$ git commit -m 'init commit'`

`git commit`으로 커밋하면 먼저 루트 디렉토리와 각 하위 디렉토리의 트리 개체를 체크섬과 함께 저장소에 저장한다.
그다음에 커밋 개체를 만들고 메타데이터와 루트 디렉토리 트리 개체를 가리키는 포인터 정보를 커밋 개체에 넣어 저장한다.
그래서 필요하면 언제든지 스냅샷을 다시 만들수 있다.

이 작업을 마치고 나면 Git저장소에는 다섯개의 데이터 개체가 생긴다. 각 파일에 대한 Blob세개 , 파일과 디렉토리구조가 들어있는
트리 개체 하나, 메타데이터와 루트 트리를 가르키는 포인터가 담긴 커밋개체 하나이다.

- Figure 9. 커밋과 트리 데이터

다시 파일을 수정하고 커밋하면 이전 커밋이 무엇인지도 저장한다.

- Figure 10. 커밋과 이전 커밋

Git의 브랜치는 커밋 사이를 가볍게 이동할 수 있는 어떤 포인터와 같은것이다. 기본적으로 Git은 Master브랜치를 만든다.
처음 커밋하면 이 master브랜치가 생성된 커밋을 가리킨다. 이후 커밋을 만들면 브랜치는 자동으로 가장 마지막 커밋을 가리킨다.

> Git 버전관리 시스템에서 마스터브랜치는 특별하지 않다. 다른 브랜치와 다른것이 없다. 다만 모든 저장소에서 마스터 브랜치가 존재하는 이유는
>Git init 명령으로 초기화 할때 자동으로 만들어진 이 브랜치를 애써 다른 이름으로 변경하지 않기 때문이다.

- Figure 11. 브랜치와 커밋 히스토리

#### 새 브랜치 생성하기.

`git branch`명령으로 test브랜치를 만든다.
새로 만든 브랜치도 지금 작업하고 있던 마지막 커밋을 가리킨다.
`$ git brach test`

- Figure 12. 한  커밋 히스토리를 가리키는 두 브랜치

지금 작업중인 브랜치가 무엇인지 깃은 어떻게 파악할까? 다른 버전 관리 시스템과는 달리 깃은 `HEAD`라는 특수한
포인터가 있다. 이 포인터는 지금 작업하는 로컬 브랜치를 가리킨다. 브랜치를 새로 만들었지만 깃을 아직 `마스터브랜치`를 가리키고있다.
`git branch`명령은 브랜치를 만들기만 하고 브랜치를 옮기지 않는다.

- Figure 13. 현재 작업중인 브랜치를 가리키는 HEAD

`git log`명령에  `--decorate` 옵션을 사용하면 쉽게 브랜치가 어떤 커밋을 가리키는지도 확인할수 있다.

`git log --oneline --decorate`**
`maset`와 `test`라는 브랜치가 ``커밋 옆에 위치하여 브랜치가 가리키는 커밋을 확인할 수가 있다.

#### 브랜치 이동하기

`git checkout`명령으로 다른 브랜치로 이동할 수 있다.
`$ git checkout test`
위 명령을 실행하면 HEAD는 test브랜치를 가리킨다.

Figure 14. HEAD는 test 브랜치를 가리킴

이제 커밋을 해보자

`$ vim test.rb`

`$ git commit -a -m 'made a change'`

Figure 15. HEAD가 가리키는 test 브랜치가 새 커밋을 가리킴

새로 커밋해서 `test`브랜치는 앞으로 이동했다. 하지만 ,`master`브랜치는 여전히 이전 커밋을 가리킨다. `master` 브랜치로 되돌아가보자
`$ git checkout master`
Figure 16. HEAD가 Checkout한 브랜치로 이동한다.

방금 실행한 명령이 한 일은 두가지이다.`master`브랜치가 가리키는 커밋을 HEAD가 가리키게 하고 워킹 디렉토리의 파일도 그 시점으로
되돌려 놓았다. 앞으로 커밋을 하면 다른 브랜치의 작업들과 별개로 진행되기 때문에 `test`브랜치에서 임시로 작업하고
원래 `master`브랜치로 돌아와서 하던 일을 계속할 수 있다.

>브랜치를 이동하면 위킹 디렉토리의 파일이 변경된다. 
>브랜치를 이동하면 위킹 디렉토리의 파일이 변경된다는 점을 기억해야한다. 이전 작업했던 브랜치로 이동하면
>워킹 디렉토리의 파일은 그 브랜치에서 가장 마지막으로 했던 작업 내용으로 변경된다.
>파일 변경시에 문제가 있어 브랜치를 이동시키는게 불가능한 경우 Git은 브랜치 이동명령을 수행하지 않는다.

파일을 수정하고 다시 커밋을 해보자

`$ vim test.rb`
`$ git commit -a -m 'other change'`
프로젝트 히스토리는 분리되어서 진행한다. 우리는 브랜치를 하나 만들어 그 브랜치에서 일을좀하고 다시 원래 브랜치로 되돌아가서 다른일을 했다.
두 작업 내용은 서로 독립적으로 각 브랜치에 존재한다. 커밋 사이를 자유롭게 이동하다가 때가 되면 두 브랜치를 `merge`한다.

Figure 17. 갈라지는 브랜치

`git log`명령으로 쉽게 확인할 수 있다. 현재 브랜치가 가리키고 있는 히스토리가 무엇이고 어떻게 갈라져 나왔는지를 보여준다.
`git log --oneline --decorate --graph --all`이라고 하면 히스토리를 출력한다.


실제로 Git의 브랜치는 어떤 한 커밋을 가리키는 40글자의 SHA-1 체크섬 파일에 불과하기 때문에 만들기 쉽고 지우기도 쉽다.
새로 브랜치를 하나만드는것은 41바이트 크기의 파일을 하나 만드는것에 불과하다.


## 브랜치와 merge의 기초

## 브랜치 관리

## 브랜치 워크플로

## 리모트 브랜치

## Rebase하기

## 요약