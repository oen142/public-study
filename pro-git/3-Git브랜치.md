## 브랜치란 무엇인가

Git이 브랜치를 다루는 과정을 이해하려면 우성 Git이 데이터를 어떻게 저장하는지 알아야한다.
Git은 데이터를 Change Set이나 변경사항으로 기록하지 않고 일련의 스냅샷으로 기록한다.

커밋하면 Git은 현 Staging Area에 있는 데이터의 스냅샷에대한 포인터, 저자나 커밋 메시지같은 메타데이터, 이전 커밋에 대한 포인터등을 포함하는
커밋 개체(Commit Object)를 저장한다. 이전 커밋 포인터가 있어서 현재 커밋이 무엇을 기준으로 바뀌엇는지를 알 수 있다.
최초 커밋을 제외한 나머지 커밋은 이전 커밋 포인터가 적어도 하나씩있고 브랜치를 합친 Merge 커밋 같은 경우 이전 커밋 포인터가 여러개 있다.

파일이 3개 있는 디렉 토리가 하나있고 이 파일을 Staging Area에 저장하고 커밋하는 예제를 살펴보자. 파일을 Stage하면
Git 저장소에 파일을 저장하고 (Git은 이것을 Blob라고 부른다) Staging Area에 해당 파일의 체크섬을 저장한다.

`$ git add README test.rb LICENSE`

`$ git commit -m 'init commit'`

`git commit`으로 커밋하면 먼저 루트 디렉토리와 각 하위 디렉토리의 트리 개체를 체크섬과 함께 저장소에 저장한다.
그다음에 커밋 개체를 만들고 메타데이터와 루트 디렉토리 트리 개체를 가리키는 포인터 정보를 커밋 개체에 넣어 저장한다.
그래서 필요하면 언제든지 스냅샷을 다시 만들수 있다.

이 작업을 마치고 나면 Git저장소에는 다섯개의 데이터 개체가 생긴다. 각 파일에 대한 Blob세개 , 파일과 디렉토리구조가 들어있는
트리 개체 하나, 메타데이터와 루트 트리를 가르키는 포인터가 담긴 커밋개체 하나이다.

- Figure 9. 커밋과 트리 데이터

다시 파일을 수정하고 커밋하면 이전 커밋이 무엇인지도 저장한다.

- Figure 10. 커밋과 이전 커밋

Git의 브랜치는 커밋 사이를 가볍게 이동할 수 있는 어떤 포인터와 같은것이다. 기본적으로 Git은 Master브랜치를 만든다.
처음 커밋하면 이 master브랜치가 생성된 커밋을 가리킨다. 이후 커밋을 만들면 브랜치는 자동으로 가장 마지막 커밋을 가리킨다.

> Git 버전관리 시스템에서 마스터브랜치는 특별하지 않다. 다른 브랜치와 다른것이 없다. 다만 모든 저장소에서 마스터 브랜치가 존재하는 이유는
>Git init 명령으로 초기화 할때 자동으로 만들어진 이 브랜치를 애써 다른 이름으로 변경하지 않기 때문이다.

- Figure 11. 브랜치와 커밋 히스토리

#### 새 브랜치 생성하기.

`git branch`명령으로 test브랜치를 만든다.
새로 만든 브랜치도 지금 작업하고 있던 마지막 커밋을 가리킨다.
`$ git brach test`

- Figure 12. 한  커밋 히스토리를 가리키는 두 브랜치

지금 작업중인 브랜치가 무엇인지 깃은 어떻게 파악할까? 다른 버전 관리 시스템과는 달리 깃은 `HEAD`라는 특수한
포인터가 있다. 이 포인터는 지금 작업하는 로컬 브랜치를 가리킨다. 브랜치를 새로 만들었지만 깃을 아직 `마스터브랜치`를 가리키고있다.
`git branch`명령은 브랜치를 만들기만 하고 브랜치를 옮기지 않는다.

- Figure 13. 현재 작업중인 브랜치를 가리키는 HEAD

`git log`명령에  `--decorate` 옵션을 사용하면 쉽게 브랜치가 어떤 커밋을 가리키는지도 확인할수 있다.

`git log --oneline --decorate`**
`maset`와 `test`라는 브랜치가 ``커밋 옆에 위치하여 브랜치가 가리키는 커밋을 확인할 수가 있다.

#### 브랜치 이동하기

`git checkout`명령으로 다른 브랜치로 이동할 수 있다.
`$ git checkout test`
위 명령을 실행하면 HEAD는 test브랜치를 가리킨다.

Figure 14. HEAD는 test 브랜치를 가리킴

이제 커밋을 해보자

`$ vim test.rb`

`$ git commit -a -m 'made a change'`

Figure 15. HEAD가 가리키는 test 브랜치가 새 커밋을 가리킴

새로 커밋해서 `test`브랜치는 앞으로 이동했다. 하지만 ,`master`브랜치는 여전히 이전 커밋을 가리킨다. `master` 브랜치로 되돌아가보자
`$ git checkout master`
Figure 16. HEAD가 Checkout한 브랜치로 이동한다.

방금 실행한 명령이 한 일은 두가지이다.`master`브랜치가 가리키는 커밋을 HEAD가 가리키게 하고 워킹 디렉토리의 파일도 그 시점으로
되돌려 놓았다. 앞으로 커밋을 하면 다른 브랜치의 작업들과 별개로 진행되기 때문에 `test`브랜치에서 임시로 작업하고
원래 `master`브랜치로 돌아와서 하던 일을 계속할 수 있다.

>브랜치를 이동하면 위킹 디렉토리의 파일이 변경된다. 
>브랜치를 이동하면 위킹 디렉토리의 파일이 변경된다는 점을 기억해야한다. 이전 작업했던 브랜치로 이동하면
>워킹 디렉토리의 파일은 그 브랜치에서 가장 마지막으로 했던 작업 내용으로 변경된다.
>파일 변경시에 문제가 있어 브랜치를 이동시키는게 불가능한 경우 Git은 브랜치 이동명령을 수행하지 않는다.

파일을 수정하고 다시 커밋을 해보자

`$ vim test.rb`
`$ git commit -a -m 'other change'`
프로젝트 히스토리는 분리되어서 진행한다. 우리는 브랜치를 하나 만들어 그 브랜치에서 일을좀하고 다시 원래 브랜치로 되돌아가서 다른일을 했다.
두 작업 내용은 서로 독립적으로 각 브랜치에 존재한다. 커밋 사이를 자유롭게 이동하다가 때가 되면 두 브랜치를 `merge`한다.

Figure 17. 갈라지는 브랜치

`git log`명령으로 쉽게 확인할 수 있다. 현재 브랜치가 가리키고 있는 히스토리가 무엇이고 어떻게 갈라져 나왔는지를 보여준다.
`git log --oneline --decorate --graph --all`이라고 하면 히스토리를 출력한다.


실제로 Git의 브랜치는 어떤 한 커밋을 가리키는 40글자의 SHA-1 체크섬 파일에 불과하기 때문에 만들기 쉽고 지우기도 쉽다.
새로 브랜치를 하나만드는것은 41바이트 크기의 파일을 하나 만드는것에 불과하다.


## 브랜치와 merge의 기초

브랜치와 merge의 진행 방향
1. 웹사이트 작업중
1. 새로운 이슈를 처리할 새 브런치를 하나 생성
1. 새로 만든 브런치에서 작업 진행

이때 중요한 문제가 생겨서 그것을 해결하는 Hotfix를 먼저 만들어야 한다.

1. 새로운 이슈를 처리하기 이전의 운영(Production) 브랜치로 이동한다.
1. Hotfix브랜치를 새로 생성한다.
1. 수정한 Hotfix 테스트를 마치고 운영 브랜치로 머지한다.
1. 다시 작업하던 브랜치로 옮겨가서 하던일을 진행한다.

#### 브랜치의 기초

figure 18. 현재 커밋 히스토리

이슈관리 시스템에서 등록된 53번 이슈를 처리한다고 하면, 이 이슈에 집중할 수 있는 브랜치를 하나 새로 만든다.
브랜치를 만들면서 checkOut까지 하려면 `git Checkout` 명령에 `-b` 라는 옵션을 추가한다.

`$ git checkout -b iss53 `



figure 19. 브랜치 포인터를 새로 만든다.

`iss53`브랜치를 체크아웃 했기 때문에 (즉 HEAD는 iss53브랜치를 가리킨다.) 뭔가 일을 하고 있으면 iss53브랜치가 앞으로 나아간다.

`$ vim index.html`
`$ git commit -a -m 'added a new footer [issue 53]'`

figure 20. 진행중인 `iss53`브랜치

만약에 만든 사이트가 문제가 생겨 즉시 고쳐야 한다. 버그를 해결한 Hotfix에 `iss53`이 섞이는 것을 방지하기 위해
`iss53`과 관련된 코드를 어디에다가 저장해 두고 원래 운영환경의 소스로 복구해야한다. Git을 사용하면 이런 노력을 들일 필요가 없이
그냥 master브랜치로 돌아가면 된다.

그렇지만, 브랜치를 이동하려면 할 일이 있다. 아직 커밋하지 않은 파일이 체크아웃 할 브랜치와 충돌나면 브랜치를 변경할 수가 ㅇ벗다.
브랜치를 변경할 때에는 워킹 디렉토리를 정리하는것이 좋다. 지금은 작업하는것을 모두 커밋하고 master브랜치로 옮긴다.

`$ git checkout master`

이때 워킹 디렉토리는 53번 이슈를 시작하기 전에 모습으로 되돌려지기 때문에 새로운 문제에 집중할 수 있는 환경이 주어진다.
Git은 자동으로 워킹 디렉토리에 파일을 추가하고 지우고 수정하새 체크아웃한 브랜치의 마지막 스냅샷으로 되돌려 놓는것을 기억해야 한다.

이젠 해결해야 할 핫 픽스가 생겼을때를 살펴보자.
hotfix라는 브랜치를 만들고 새로운 이슈를 해결할 때 까지 사용한다.

`$ git checkout -b hotfix`

`$ vim index.html`

`$ git commit -a -m 'fixed the broken email address`

figure21. master브랜치에서 갈라져나온 hotfix브랜치

운영환경에 적용하려면 문제를 제대로 고쳤는지 테스트하고 master브랜치에 합쳐야 한다.

`$ git checkout master`

`$ git merge hotfix`

머지 메시지에서 `fast-forward`가 나온다. `hotfix` 브랜치가 가리키는 커밋이 그전 커밋에 기반한 브랜치 이기 때문에
브랜치 포인터는 머지 과정없이 그저 최신 커밋으로 이동한다. 이런 머지 방식을 `fast forward`라고 부른다.
다시만해 A브랜치에서 다른 B브랜치를 머지할때 B브랜치가 A브랜치 이후의 커밋을 가리키고 있으면 그저 A브랜치가 B브랜치와 동일한 커밋을
가리키도록 이동시킨것 이다.
이제 hotfix는 마스터 브랜치에 포함되었고 운영환경에 적용할 수 있는 상태가 되었다고 가정하자.


figure 22 merge후 hotfix 같은것을 가리키는 master 브랜치

급한 문제를 해결하고 마스터 브랜치에 적용하고 나면 다시 일하던 브랜치로 돌아가야 한다.
이제는 더이상 필요없는 핫픽스 브랜치는 삭제한다. `git branch`명령에 `-d`옵션을 주고 삭제한다.

`$ git branch -d hotfix`

이슈 53번을 처리하던 환경으로 돌아간다.

`$ git checkout iss53`

`$ vim index.html`

`$ git commit -a -m 'finished the new footer [issue 53]`

figure 23. 마스터와 별개로 진행하는 iss53 브랜치

위에서 작업한 hotfix가 iss53브랜치에는 영향을 끼지지 않는다는것이 중요하다. `git merge master` 명령으로 마스터브랜치를 iss53브랜치에
머지하면 iss53브랜치에 hotfix가 적용된다. 아니면 iss53브랜치가 마스터에 머지할수 있는 수준까지 기다렸다가 머지하면 hotfix와 iss53 브랜치가 합쳐진다.


#### merge의 기초

53번 이슈를 다 구현하고 마스터 브랜치에 머지하는 과정을 살펴보자. iss53 브랜치를 마스터 브랜치에 머지하는 것은 hotfix브랜치를 머지하는것과 같다.
`git merge`명령으로 합칠 브랜치에서 합쳐질 브랜치를 Merge하면 된다.

`$ git checkout master`

`$ git merge iss53`

hotfix를 머지했을때와 메시지가 다르다. 현재 브랜치가 가리키는 커밋이 merge할 브랜치의 조상이 아니므로
git은 `Fast-forward`로 머지하지 않는다. 이 경우에는 git은 각 브랜치가 가리키는 커밋 두개와 공통 조상 하나를
사용하여 `3-way merge`를 한다.

figure 24. 커밋 3개를 merge

단순히 브랜치 포인터를 최신 커밋으로 옮기는것이 아니라 `3-way merge`의 결과를 별도의 커밋으로 만들고 해당 브랜치가 그 커밋을 가리키도록
이동시킨다. 이런 커밋은 부모가 여러개고 merge 커밋이라고 부른다.

figure 25. merge커밋


깃은 머지하는데 필요한 최적의 공통 조상을 자동으로 찾는다. 이러한 기능도 깃이 다른 버전관리 시스템보다 좋은 이유이다.
다른 버전관리 시스템은 개발자가 직접 찾아 머지해야한다.

iss53 브랜치를 마스터에 머지하고 나면 더는 iss53브랜치는 필요가 없다. 삭제하고 이슈를 상태처리로 만든다.

`$ git branch -d iss53`

#### 충돌의 기초

가끔씩 `3-way merge`가 실패할 때도 있다. merge하는 두 브랜치에서 같은 파일의 한 부분을 동시에 수정하고 merge하면 깃은 해당부분을 머지하지 못한다.
예를들면, 53번 이슈와 hotfix가 같은 부분을 수정했다면 머지하지 못하고 충돌(Conflict)메시지를 출력한다.

`$ git merge iss53`

```
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result
```

깃은 자동으로 머지하지 못해서 새 커밋이 생기지 안흔다. 변경사하의 충돌을 개발자가 해결하지 않는 한 머지과정을 진행할 수가 없다.
머지 충돌이 일어났을때 깃이 어느 파일을 머지할수 없는지 살펴보려면 `git status`명령을 사용한다.

`$ git status
//todo
`

충돌이 일어난 파일은 unmerged 상태로 표시된다. 깃은 충돌이난 부분은 표준 형식에 따라 표시해준다.
개발자는 해당 부분을 수동으로 수정해야 한다.


`=====` 위쪽의 내용은 HEAD버전(merge명령을 실행할 때 작업하던 마스터 브랜치)의 내용이고 아래는 `iss53`브랜치의 내용이다.
충돌을 해결 하려면 위쪽이나 아래쪽의 내용중에서 고르거나 새로 작성하여 머지 해야한다.



## 브랜치 관리

## 브랜치 워크플로

## 리모트 브랜치

## Rebase하기

## 요약